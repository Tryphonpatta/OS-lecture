## Operating System Service

- User interface
- Program execution
- I/O operations
- File-system manipulation
- Communications
- Error detection
- Resource allocation
- Logging
- Protection and security
    - Protection
        - all access in system is controlled
    - Security
        - outsider’s access

## A View of Operating System Services
![image](https://github.com/user-attachments/assets/2c45deea-da65-4c4c-8349-f4c34fc57bb6)



## System Calls

- A system call in an operating system (OS) is a mechanism that allows a program to request a service from the kernel, which is the core part of the OS. These services include tasks like file operations (opening, reading, writing files), process control (creating or terminating processes), communication, and more. System calls serve as the interface between a user-level application and the OS, enabling the application to perform low-level operations that it cannot perform directly.
- When a program makes a system call, it switches from user mode (where it has limited privileges) to kernel mode (where it has full access to the system hardware). The kernel then executes the requested service and returns control to the program, usually with some result or status code.

Common examples of system calls include:

- **`open`**: Opens a file.
- **`read`**: Reads data from a file or device.
- **`write`**: Writes data to a file or device.
- **`fork`**: Creates a new process.
- **`exec`**: Replaces the current process image with a new one.
- **`exit`**: Terminates a process.

## System Call Parameter Passing

Three general methods used to pass parameters to the OS

- Simplest: pass the parameters in registers
    - In some cases, may be more parameters than registers
- Parameters stored in a block, or table, in memory, and address of
block passed as a parameter in a register
    - This approach taken by Linux and Solaris
- Parameters placed, or pushed, onto the **`stack`** by the program and
popped off the stack by the operating system
- Block and stack methods do not limit the number or length of
parameters being passed

## Types of System Calls

- Process control
    - create process, terminate process
    - end, abort
    - load, execute
    - …
- File management
    - create file, delete file
    - open, close file
    - …
- Device management
    - request device, release device
    - get device attributes, set device attributes
    - …
- Information maintenance
    - get time or date, set time or date
    - get system data, set system data
    - …
- Communications
    - create, delete communication connection
    - send, receive messages if `message passing model` to `host
    name` or `process name`
        - From client to server
    - Shared-memory model create and gain access to memory
    regions
- Protection
    - Control access to resources
    - Get and set permissions
    - Allow and deny user access

## Linkers and Loaders

`Linkers`

- A linker is a program that takes one or more object files generated by a compiler and combines them into a single executable file.

`Loaders`

- A loader is a part of the operating system responsible for loading the executable file into memory and starting its execution.

Sum.

- **`Linkers`** are responsible for combining object files, resolving symbols, and producing an executable file.
- **`Loaders`** are responsible for loading the executable into memory, setting up the environment, and starting the program's execution.

## Design and Implementation

`User goals` and `System goals`

- `User goals` – operating system should be convenient to use,
easy to learn, reliable, safe, and fast
- `System goals` – operating system should be easy to design,
implement, and maintain, as well as flexible, reliable, error-free,
and efficient

## Policy and Mechanism

- `Policy`: What needs to be done?
    - Example: Interrupt after every 100 seconds
- `Mechanism`: How to do something?
    - Example: timer

Important principle: separate policy from mechanism

## Operating System Structure

- General-purpose OS is very large program
- Various ways to structure ones
    - Simple structure – MS-DOS
    - More complex – UNIX
    - Layered – an abstraction
    - Microkernel – Mach

### Monolithic Structure – Original UNIX

- UNIX – limited by hardware functionality, the original UNIX operating
system had limited structuring.
- The UNIX OS consists of two separable parts
    - Systems programs
    - The kernel
        - Consists of everything below the system-call interface and
        above the physical hardware
        - Provides the file system, CPU scheduling, memory
        management, and other operating-system functions; a large
        number of functions for one level
        
        ![image](https://github.com/user-attachments/assets/c5523bb0-7d54-440b-a07d-18fc6dfaaabd)

        

### Microkernels

- Moves as much from the kernel into user space
- Mach is an example of microkernel
    - Mac OS X kernel (Darwin) partly based on Mach
- Communication takes place between user modules using
message passing
- Benefits:
    - Easier to extend a microkernel
    - Easier to port the operating system to new architectures
    - More reliable (less code is running in kernel mode)
    - More secure
- Detriments:
    - Performance overhead of user space to kernel space
    communication

| Feature | Monolithic Kernel | Microkernel | Hybrid Kernel |
| --- | --- | --- | --- |
| Structure | Single large kernel with all OS services integrated. | Minimal kernel with essential services only; other services run in user space. | Combines elements of both monolithic and microkernel architectures. |
| Services in Kernel Space | Includes all core OS services (e.g., file systems, device drivers, networking). | Only essential services like IPC, scheduling, and low-level hardware management. | Critical services are in the kernel, while others might run in user space. |
| Performance | High performance due to direct service calls within the kernel. | Potential performance overhead due to inter-process communication (IPC). | Attempts to achieve a balance between performance and modularity. |
| Modularity | Low modularity; changes in one part of the kernel may affect others. | High modularity; services are isolated and interact through well-defined interfaces. | Moderate modularity; some parts are modular, while core services remain integrated. |
| Security | Lower security; a bug in one service can compromise the entire system. | Higher security; services are isolated, reducing the risk of system-wide failure. | Moderate security; attempts to isolate critical services while maintaining performance. |
| Stability | Less stable; a crash in one service can crash the entire system. | More stable; failures in user-space services do not typically crash the entire system. | Stability varies; aims to isolate failures in non-critical services. |
| Development Complexity | Easier to develop and debug since all services are in one place. | More complex to develop and debug due to the separation of services. | Complex, as it involves integrating the best aspects of both monolithic and microkernel approaches. |
| Examples | Linux, UNIX, Windows NT | Minix, QNX, GNU Hurd | macOS, Windows NT (modern versions), XNU (used in macOS and iOS) |
